@import tools.vitruv.optggs.driver.Project
@param Project p
/**
* Generated by OpTGGs
*/
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.emoflon.neo.api.${p.packageName()}.API_Common;
import org.emoflon.neo.api.${p.packageName()}.API_Transform;
import org.emoflon.neo.api.${p.packageName()}.tgg.API_${p.name()}_MI;
import org.emoflon.neo.emsl.eMSL.Model;
import org.emoflon.neo.cypher.models.NeoCoreBuilder;
import org.emoflon.neo.engine.modules.NeoGenerator;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import org.emoflon.neo.engine.api.constraints.IConstraint;
import org.emoflon.neo.api.${p.packageName()}.tgg.API_${p.name()}_GEN;
import org.emoflon.neo.engine.modules.ilp.ILPFactory.SupportedILPSolver;
import org.emoflon.neo.engine.modules.monitors.HeartBeatAndReportMonitor;
import org.emoflon.neo.engine.modules.startup.NoOpStartup;
import org.emoflon.neo.engine.modules.terminationcondition.NoMoreMatchesTerminationCondition;
import org.emoflon.neo.engine.modules.valueGenerators.LoremIpsumStringValueGenerator;
import org.emoflon.neo.engine.modules.valueGenerators.ModelNameValueGenerator;
import org.emoflon.neo.engine.modules.analysis.TripleRuleAnalyser;
import org.emoflon.neo.engine.modules.updatepolicies.ModelIntegrationOperationalStrategy;
import org.emoflon.neo.engine.modules.startup.PrepareContextDeltaAttributes;
import org.emoflon.neo.engine.modules.ruleschedulers.MIRuleScheduler;
import org.emoflon.neo.engine.modules.matchreprocessors.MIReprocessor;

@SuppressWarnings("unused")
public class ${p.name()}SyncRunner {
    protected static SupportedILPSolver solver = SupportedILPSolver.Sat4J;
    protected ModelIntegrationOperationalStrategy modelIntegration;
    protected static final Logger logger = Logger.getLogger(${p.name()}SyncRunner.class);
    protected String srcModelName;
    protected String trgModelName;

    public ${p.name()}SyncRunner(String srcModelName, String trgModelName) {
        this.srcModelName = srcModelName;
        this.trgModelName = trgModelName;
    }

    public void run(Model src, Model tgt) throws Exception {
        try (var builder = API_Common.createBuilder()) {
            new API_Transform(builder).exportMetamodelsFor${p.name()}();

            builder.clearDataBase();
            builder.exportEMSLEntityToNeo4j(src);
            builder.exportEMSLEntityToNeo4j(tgt);

            var generator = createGenerator(builder, src.getName(), tgt.getName());

            logger.info("Running generator...");
            generator.generate();
            logger.info("Generator terminated.");
        }
    }

    public NeoGenerator createGenerator(NeoCoreBuilder builder, String srcModelName, String trgModelName) {
        var api = new API_Transform(builder);
        var genAPI = new API_${p.name()}_GEN(builder);
        var miAPI = new API_${p.name()}_MI(builder);
        var genRules = genAPI.getAllRulesFor${p.name()}_GEN();
        var analyser = new TripleRuleAnalyser(new API_Transform(builder).getTripleRulesOf${p.name()}());

        modelIntegration = new ModelIntegrationOperationalStrategy(//
            solver, //
            builder, //
            genRules, //
            miAPI.getAllRulesFor${p.name()}_MI(), //
            api.getConstraintsOf${p.name()}(), //
            srcModelName, //
            trgModelName//
        );

        var gen = new NeoGenerator(//
            miAPI.getAllRulesFor${p.name()}_MI(), //
            new PrepareContextDeltaAttributes(builder, srcModelName, trgModelName), //
            new NoMoreMatchesTerminationCondition(), //
            new MIRuleScheduler(analyser), //
            modelIntegration, //
            new MIReprocessor(analyser), //
            modelIntegration, //
            new HeartBeatAndReportMonitor(), //
            new ModelNameValueGenerator(srcModelName, trgModelName), //
            List.of(new LoremIpsumStringValueGenerator())
        );
        RegisterAttributeConstraints.register(gen);
        return gen;
    }
}
