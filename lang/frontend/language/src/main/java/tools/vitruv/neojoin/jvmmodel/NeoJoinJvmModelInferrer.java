/*
 * generated by Xtext
 */
package tools.vitruv.neojoin.jvmmodel;

import com.google.inject.Inject;
import com.google.inject.name.Named;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import tools.vitruv.neojoin.Constants;
import tools.vitruv.neojoin.ast.ViewTypeDefinition;

/**
 * Xbase expressions within an Xtext language work by defining a jvm model (= a set of classes).
 * This model is used by Xtext for type checking and code completion in Xbase expressions.
 * This class infers such a jvm model
 * <ul>
 *     <li>for all source models to tell Xtext which classes and features are available and their types (see {@link SourceModelInferrer}) and</li>
 *     <li>embeds every expression within the query file into a method to tell Xtext the available local variables,
 *     their types and the expected return type of the expression (see {@link QueryModelInferrer})</li>
 * </ul>
 * Further information can be found in the <a href="https://eclipse.dev/Xtext/documentation/305_xbase.html#xbase-inferred-type">Xtext documentation</a>.
 */
public class NeoJoinJvmModelInferrer extends AbstractModelInferrer {

    @Inject
    private JvmTypesBuilder typesBuilder;

    @Inject
    @Named(Constants.ImportPackageRegistry)
    private EPackage.Registry packageRegistry;

    @Inject
    private ExpressionHelper expressionHelper;

    @Override
    public void infer(EObject obj, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) {
        if (obj instanceof ViewTypeDefinition viewType) {
            var typeRegistry = getOrCreateSourceModelTypes(viewType.eResource().getResourceSet());
            new QueryModelInferrer(
                acceptor,
                viewType,
                typeRegistry,
                typesBuilder,
                _typeReferenceBuilder,
                expressionHelper
            ).infer();
        } else {
            super.infer(obj, acceptor, preIndexingPhase);
        }
    }

    private static final URI SourceTypeRegistryURI = URI.createURI("SourceTypeRegistry");

    /**
     * Create source meta-model types only once per resource set and share them between different resources
     * (i.e., different NeoJoin query files opened simultaneously in the IDE). This saves same resources and
     * more importantly prevents collisions that would otherwise occur if the same source class is generated
     * within multiple resources within the same resource set.
     */
    private TypeRegistry getOrCreateSourceModelTypes(ResourceSet resourceSet) {
        var typeRegistry = (TypeRegistry) resourceSet.getResource(SourceTypeRegistryURI, false);
        if (typeRegistry == null) {
            typeRegistry = new TypeRegistry(SourceTypeRegistryURI);
            new SourceModelInferrer(typeRegistry, packageRegistry, _typeReferenceBuilder).infer();
            resourceSet.getResources().add(typeRegistry);
        }

        return typeRegistry;
    }

}
