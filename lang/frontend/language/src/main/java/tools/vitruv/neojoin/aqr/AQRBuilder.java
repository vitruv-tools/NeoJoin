package tools.vitruv.neojoin.aqr;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.xbase.XExpression;
import org.jspecify.annotations.Nullable;
import tools.vitruv.neojoin.Constants;
import tools.vitruv.neojoin.ast.AbstractFeature;
import tools.vitruv.neojoin.ast.AbstractMainQuery;
import tools.vitruv.neojoin.ast.Body;
import tools.vitruv.neojoin.ast.ConcreteFeature;
import tools.vitruv.neojoin.ast.ConcreteMainQuery;
import tools.vitruv.neojoin.ast.Export;
import tools.vitruv.neojoin.ast.Feature;
import tools.vitruv.neojoin.ast.Import;
import tools.vitruv.neojoin.ast.MainQuery;
import tools.vitruv.neojoin.ast.Query;
import tools.vitruv.neojoin.ast.SubQuery;
import tools.vitruv.neojoin.ast.ViewTypeDefinition;
import tools.vitruv.neojoin.jvmmodel.ExpressionHelper;
import tools.vitruv.neojoin.jvmmodel.TypeInfo;
import tools.vitruv.neojoin.jvmmodel.TypeResolutionException;
import tools.vitruv.neojoin.utils.AstUtils;
import tools.vitruv.neojoin.utils.Pair;
import tools.vitruv.neojoin.utils.TypeCasts;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import static tools.vitruv.neojoin.aqr.AQRInvariantViolatedException.invariant;
import static tools.vitruv.neojoin.aqr.AQRInvariantViolatedException.invariantFailed;
import static tools.vitruv.neojoin.utils.Assertions.check;
import static tools.vitruv.neojoin.utils.Assertions.fail;

/**
 * Transforms the already {@link ViewTypeDefinition abstract representation of a query} provided by Xtext into the {@link AQR}
 * by performing a series of normalizations, including:
 * <ul>
 *     <li>inferring feature types based on the Xtend expressions</li>
 *     <li>transforming subqueries into top-level queries</li>
 *     <li>generating queries for classes which are implicitly referenced (e.g. as reference type) but not explicitly generated by a separate query</li>
 *     <li>populating query target classes with features when no body was provided (e.g. {@code from Food create})</li>
 *     <li>...</li>
 * </ul>
 *
 * @implNote The implementation uses {@link AQRInvariantViolatedException#invariant(boolean) invariant(...)} for invariants
 * that should hold for {@link tools.vitruv.neojoin.validation valid} queries. Invariants that should always hold (even for
 * invalid queries) are checked with assertion methods from {@link tools.vitruv.neojoin.utils.Assertions Assertions}.
 */
public class AQRBuilder {

    private final ViewTypeDefinition viewTypeDefinition;
    private final ExpressionHelper expressionHelper;

    private final Queue<Pair<AQRTargetClass, @Nullable Query>> populationQueue = new ArrayDeque<>(); // target class + query it originated from (or null if implicit)

    private final Set<EDataType> encounteredDataTypes = new HashSet<>();

    private final Set<AQRTargetClass> targetClasses = new HashSet<>();
    private final Map<EClass, Set<AQRTargetClass>> sourceClassToAQR = new HashMap<>(); // source class -> aqr targets
    private final Map<Query, AQRTargetClass> queryToTarget = new HashMap<>(); // query (Query | SubQuery) -> target class

    public AQRBuilder(ViewTypeDefinition viewTypeDefinition, ExpressionHelper expressionHelper) {
        this.viewTypeDefinition = viewTypeDefinition;
        this.expressionHelper = expressionHelper;
    }

    /**
     * Transforms the given {@link ViewTypeDefinition} into an {@link AQR}.
     *
     * @implNote First all target classes that are explicitly generated by a query are created. Afterward these classes
     * are populated with features (see {@link #populationQueue}) and potentially missing target classes for
     * implicitly referenced source classes are created lazily when encountered.
     */
    public AQR build() {
        check(targetClasses.isEmpty(), "AQR already built");

        // create empty (= without features) target classes for all queries
        AstUtils.getAllQueries(viewTypeDefinition).forEach(this::createTargetClass);

        // add super classes to target classes
        for (var entry : populationQueue) {
            addSuperClassesToTargetClass(entry.left(), entry.right());
        }
        
        // populate target classes
        while (!populationQueue.isEmpty()) {
            var entry = populationQueue.poll();
            //noinspection DataFlowIssue - false positive
            populateTargetClass(entry.left(), entry.right() == null ? null : AstUtils.getBody(entry.right()));
        }

        // identify and verify inheritance
        for (var targetClass : targetClasses) {
            applyInheritance(targetClass);
        }

        var root = createRootIfNeededAndInit();

        return new AQR(
            createExport(viewTypeDefinition.getExport()),
            viewTypeDefinition.getImports().stream().map(AQRBuilder::createImport).toList(),
            encounteredDataTypes.stream().filter(dataType -> dataType.getEPackage() != EcorePackage.eINSTANCE).toList(),
            List.copyOf(targetClasses),
            root
        );
    }

    private static AQRExport createExport(Export export) {
        return new AQRExport(
            Objects.requireNonNull(export.getPackage()),
            Objects.requireNonNull(URI.createURI(export.getUri()))
        );
    }

    private static AQRImport createImport(Import imp) {
        return new AQRImport(
            Objects.requireNonNull(imp.getPackage()),
            Objects.requireNonNull(AstUtils.getImportAlias(imp))
        );
    }

    private AQRTargetClass getTargetForQuery(Query query) {
        var target = queryToTarget.get(query);
        invariant(target != null);
        return target;
    }

    private AQRTargetClass createTargetClass(String name, boolean isAbstract, @Nullable AQRSource source, @Nullable Query query) {
        var target = new AQRTargetClass(name, isAbstract, source, new ArrayList<>(), new ArrayList<>());

        targetClasses.add(target);

        if (query != null) {
            var previous = queryToTarget.put(query, target);
            invariant(previous == null);
        }

        if (source != null) {
            source.allFroms().forEach(f -> {
                sourceClassToAQR.computeIfAbsent(f.clazz(), (k) -> new HashSet<>()).add(target);
            });
        }

        populationQueue.add(new Pair<>(target, query));
        return target;
    }

    private void createTargetClass(Query query) {
        if (query instanceof ConcreteMainQuery mainQuery) {
            createTargetClass(
                AstUtils.getTargetName(mainQuery),
                false,
                mainQuery.getSource() != null ? AQRSourceBuilder.createSource(mainQuery.getSource()) : null,
                mainQuery
            );
        } else if (query instanceof AbstractMainQuery mainQuery) {
            createTargetClass(
                AstUtils.getTargetName(mainQuery),
                true,
                null,
                mainQuery
            );
        } else if  (query instanceof SubQuery subQuery) {
            var sourceType = AstUtils.inferSubQuerySourceType(subQuery, expressionHelper);
            invariant(sourceType != null);
            createTargetClass(
                AstUtils.getTargetName(subQuery, sourceType),
                false,
                AQRSourceBuilder.createSource(sourceType),
                subQuery
            );
        } else {
            fail();
        }
    }

    /**
     * Returns the existing target class associated with a source class or creates a new one if none is found.
     * Also checks that there is at most one target class associated with the given source class.
     *
     * @param source source class for which to find the corresponding target class
     * @return corresponding target class
     */
    private AQRTargetClass getOrCreateTargetClass(EClass source) {
        var targets = sourceClassToAQR.get(source);
        if (targets == null) {
            return createTargetClass(source.getName(), source.isAbstract(), AQRSourceBuilder.createSource(source), null);
        }

        invariant(
            targets.size() == 1,
            () -> "Ambiguous target class for source class '%s'. Possible candidates: %s".formatted(
                source.getName(),
                targets.stream().map(AQRTargetClass::name).collect(Collectors.joining(", "))
            )
        );

        return targets.iterator().next();
    }

    private void addSuperClassesToTargetClass(AQRTargetClass targetClazz, @Nullable Query query) {
        if (query != null && query instanceof MainQuery mainQuery) {
            for (EObject superClass : mainQuery.getSuperClasses()) {
                invariant(superClass instanceof Query, "Classes can only extend classes created from other queries");

                targetClazz.superClasses().add(getTargetForQuery((Query) superClass));
            }
        }
    }

    /**
     * Populates the target class with features specified in the given body or copies all features if no body was given.
     *
     * @param targetClazz target class to populate
     * @param body        body of the query
     */
    private void populateTargetClass(AQRTargetClass targetClazz, @Nullable Body body) {
        if (body != null) { // create features based on definition in Body
            for (Feature feature : AstUtils.getFeatures(body)) {
                targetClazz.features().add(createFeature(feature));
            }
        } else { // copy all features from the source class
            invariant(targetClazz.source() != null, "Query without source must have a body");
            invariant(targetClazz.source().joins().isEmpty(), "Query with join must have a body");

            var sourceClazz = targetClazz.source().from().clazz();
            for (var feature : sourceClazz.getEStructuralFeatures()) {
                targetClazz.features().add(copyFeature(feature));
            }
        }
    }

    /**
     * Creates a feature by copying the given {@link EStructuralFeature} from the source class.
     */
    private AQRFeature copyFeature(EStructuralFeature feature) {
        var kind = new AQRFeature.Kind.Copy.Implicit(feature);
        var options = AQRFeatureOptionsBuilder.build(feature);
        if (feature instanceof EAttribute attr) {
            var type = attr.getEAttributeType();
            encounteredDataTypes.add(type);
            return new AQRFeature.Attribute(attr.getName(), type, kind, options);
        } else if (feature instanceof EReference ref) {
            var target = getOrCreateTargetClass(ref.getEReferenceType());
            return new AQRFeature.Reference(ref.getName(), target, kind, options);
        } else {
            return fail();
        }
    }

    /**
     * Create a feature based on the given definition.
     */
    private AQRFeature createFeature(Feature feature) {
        var kind = getFeatureKind(feature);
        var name = getFeatureName(feature, kind);

        TypeInfo inferredType = null;
        AQRFeature.Options options;
        SubQuery subQuery = null;
        if (feature instanceof ConcreteFeature concreteFeature) {
            inferredType = inferType(concreteFeature.getExpression());
            options = AQRFeatureOptionsBuilder.build(feature, kind.source(), inferredType.isMany());
            subQuery = concreteFeature.getSubQuery();
        } else if (feature instanceof AbstractFeature) {
            options = AQRFeatureOptionsBuilder.build(feature, null, AstUtils.isManyMultiplicityDefinition(feature));
        } else {
            return fail("Feature must be either a concrete or an abstract feature");
        }

        if (isAttribute(inferredType, feature.getType())) {
            invariant(subQuery == null);
            var type = determineAttributeType(inferredType, (EDataType) feature.getType(), kind);
            encounteredDataTypes.add(type);
            return new AQRFeature.Attribute(name, type, kind, options);
        } else {
            var type = determineReferenceType(inferredType, (Query) feature.getType(), subQuery);
            return new AQRFeature.Reference(name, type, kind, options);
        }
    }

    /**
     * Determines the {@link AQRFeature.Kind kind} of the feature.
     */
    private AQRFeature.Kind getFeatureKind(Feature feature) {
        if (feature instanceof ConcreteFeature concreteFeature) {
            return switch (concreteFeature.getOp()) {
                case COPY -> {
                    try {
                        var type = expressionHelper.getFeatureOrNull(concreteFeature.getExpression());
                        invariant(
                            type != null,
                            () -> "Copy feature expression must reference a feature: " + concreteFeature.getExpression()
                        );
                        yield new AQRFeature.Kind.Copy.Explicit(type, concreteFeature.getExpression());
                    } catch (TypeResolutionException e) {
                        yield invariantFailed(); // should have been handled by Xbase type checking
                    }
                }
                case CALCULATE -> new AQRFeature.Kind.Calculate(concreteFeature.getExpression());
            };
        } else if (feature instanceof AbstractFeature) {
            return new AQRFeature.Kind.Abstract();
        } else {
            return fail("Feature must be either a concrete or an abstract feature");
        }
    }

    /**
     * Determines the name of the feature based on the given {@link Feature} and its kind.
     */
    private static String getFeatureName(Feature feature, AQRFeature.Kind kind) {
        if (feature.getName() != null) {
            return feature.getName();
        }

        if (kind instanceof AQRFeature.Kind.Copy copy) {
            return copy.source().getName();
        } else if (kind instanceof AQRFeature.Kind.Calculate) {
            return invariantFailed("Calculated feature must have a name: " + ((ConcreteFeature) feature).getExpression());
        } else if (kind instanceof AQRFeature.Kind.Override overriding) {
            return overriding.overwritten().name();
        } else {
            return fail();
        }
    }

    /**
     * Determines whether a feature is an attribute or reference based on the inferred type and the explicit type.
     *
     * @return {@code true} if the feature is an attribute, {@code false} if it is a reference
     */
    private boolean isAttribute(@Nullable TypeInfo inferredType, @Nullable EObject explicitType) {
        if (explicitType != null) {
            return explicitType instanceof EDataType;
        } else {
            invariant(inferredType != null && inferredType.classifier() != null);
            return inferredType.classifier() instanceof EDataType;
        }
    }

    /**
     * Determine the {@link EAttribute#getEAttributeType() type} of the attribute.
     */
    private EDataType determineAttributeType(
        @Nullable TypeInfo inferredType,
        @Nullable EDataType explicitType,
        AQRFeature.Kind kind
    ) {
        if (explicitType != null) { // explicit type
            invariant(inferredType == null || inferredType.classifier() == null || isAssignable(explicitType, inferredType.classifier()));
            return explicitType;
        } else { // implicit type
            invariant(inferredType != null && inferredType.classifier() != null);
            if (kind instanceof AQRFeature.Kind.Copy copy) {
                var type = (EDataType) copy.source().getEType();
                invariant(isAssignable(type, inferredType.classifier()));
                return type;
            } else {
                return (EDataType) inferredType.classifier();
            }
        }
    }

    private static boolean isAssignable(EDataType to, EClassifier from) {
        if (to.getInstanceClass() == null || from.getInstanceClass() == null) {
            return to == from;
        } else {
            return TypeCasts.canCast(from.getInstanceClass(), to.getInstanceClass());
        }
    }

    /**
     * Determine the {@link EReference#getEReferenceType() type} of the reference.
     */
    private AQRTargetClass determineReferenceType(
        @Nullable TypeInfo inferredType,
        @Nullable Query explicitType,
        @Nullable SubQuery subQuery
    ) {
        if (explicitType != null) {
            invariant(subQuery == null || explicitType == subQuery);
            if (inferredType != null && inferredType.classifier() != null) {
                var inferredClass = (EClass) inferredType.classifier();

                // check that the inferred type is assignable to the explicit type
                if (explicitType instanceof ConcreteMainQuery explicitMainQueryType) {
                    invariant(explicitMainQueryType.getSource() != null, "Cannot reference a query without source");
                    invariant(AstUtils.checkSourceType(explicitMainQueryType.getSource(), inferredClass));
                } else if (explicitType instanceof AbstractMainQuery) {
                    // TODO
                } else {
                    var explicitSubQueryType = (SubQuery) explicitType;
                    var subQuerySourceType = AstUtils.inferSubQuerySourceType(
                        explicitSubQueryType,
                        expressionHelper
                    );
                    invariant(subQuerySourceType != null);
                    invariant(AstUtils.checkSourceType(subQuerySourceType, inferredClass));
                }
            }
            return getTargetForQuery(explicitType);
        } else {
            invariant(inferredType != null && inferredType.classifier() instanceof EClass); // includes null check
            if (subQuery != null) {
                return getTargetForQuery(subQuery);
            } else {
                return getOrCreateTargetClass((EClass) inferredType.classifier());
            }
        }
    }

    private TypeInfo inferType(XExpression expression) {
        try {
            return Objects.requireNonNull(expressionHelper.inferEType(expression));
        } catch (TypeResolutionException e) {
            return invariantFailed(); // should have been handled by Xbase type checking
        }
    }

    private void applyInheritance(AQRTargetClass targetClass) {
        var superClassFeatures = targetClass.allSuperClasses().stream().flatMap(superClass -> superClass.features().stream()).toList();

        // update overwriting features
        targetClass.features().replaceAll(feature -> {
            var overwrittenFeatures = superClassFeatures.stream().filter(superClassFeature -> superClassFeature.name().equals(feature.name())).toList();
            if (overwrittenFeatures.isEmpty()) {
                return feature;
            }

            invariant(overwrittenFeatures.size() == 1);
            var overwrittenFeature = overwrittenFeatures.get(0);

            invariant(feature.options().equals(overwrittenFeature.options()), "Overwriting features may not change modifiers");

            if (feature instanceof AQRFeature.Attribute attribute) {
                invariant(overwrittenFeature instanceof AQRFeature.Attribute, "Attribute must overwrite attribute");
                var overwrittenAttribute = (AQRFeature.Attribute)overwrittenFeature;
                invariant(overwrittenAttribute.type().equals(attribute.type()), "Type of overwriting feature must be equal to type of overwritten feature");

                return attribute.withFeatureKind(new AQRFeature.Kind.Override(overwrittenFeature, feature.kind().expression()));
            } else if (feature instanceof AQRFeature.Reference reference) {
                invariant(overwrittenFeature instanceof AQRFeature.Reference, "Reference must overwrite reference");
                var overwrittenReference = (AQRFeature.Reference)overwrittenFeature;
                invariant(overwrittenReference.type().equals(reference.type()), "Type of overwriting feature must be equal to type of overwritten feature");

                return reference.withFeatureKind(new AQRFeature.Kind.Override(overwrittenFeature, feature.kind().expression()));
            } else {
                throw new IllegalStateException("AQRFeature is a sealed interface therefore this check should be exhaustive");
            }
        });

        // check if all inherited features are overwritten
        var missingFeatures = superClassFeatures.stream().filter(superClassFeature -> !targetClass.features().stream().filter(feature ->
            feature.name().equals(superClassFeature.name()) &&
            (feature.kind() instanceof AQRFeature.Kind.Override)
        ).findAny().isPresent()).toList();
        if (!missingFeatures.isEmpty()) {
            invariant(!missingFeatures.isEmpty(), "Sub classes must overwrite all inherited features");
        }
    }

    private AQRTargetClass createRootIfNeededAndInit() {
        AQRTargetClass root;

        var rootQuery = findRootQuery();
        if (rootQuery != null) {
            root = getTargetForQuery(rootQuery);
        } else {
            root = new AQRTargetClass(Constants.DefaultRootClassName, false, null, new ArrayList<>(), new ArrayList<>());
            targetClasses.add(root);
        }

        populateRoot(root);
        return root;
    }

    /**
     * Finds the root query of the view type definition if it exists and ensures that there is at most one.
     *
     * @return the root query if it exists, {@code null} otherwise
     */
    private @Nullable MainQuery findRootQuery() {
        var roots = viewTypeDefinition.getQueries().stream().filter(query -> query instanceof ConcreteMainQuery mainQuery && mainQuery.isRoot()).toList();
        invariant(
            roots.size() <= 1,
            () -> "Multiple root queries found: " + roots.stream()
                .map(AstUtils::getTargetName)
                .collect(Collectors.joining(", "))
        );

        return roots.isEmpty() ? null : roots.get(0);
    }

    private static final AQRFeature.Options RootReferenceOptions = new AQRFeature.Options(
        0,
        ETypedElement.UNBOUNDED_MULTIPLICITY,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        true
    );

    /**
     * Populate the root class with containment references to all other target classes.
     *
     * @param root the root target class to populate
     */
    private void populateRoot(AQRTargetClass root) {
        for (var target : targetClasses) {
            if (target == root) {
                continue;
            }

            var featureName = Constants.RootReferenceNameFormat.formatted(target.name());
            invariant(
                root.features().stream().noneMatch(f -> f.name().equals(featureName)),
                () -> "Duplicated feature name '%s' in root class".formatted(featureName)
            );
            root.features().add(
                new AQRFeature.Reference(
                    featureName,
                    target,
                    new AQRFeature.Kind.Generate(),
                    RootReferenceOptions
                )
            );
        }
    }

}
