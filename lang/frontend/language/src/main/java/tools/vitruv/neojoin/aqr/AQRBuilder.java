package tools.vitruv.neojoin.aqr;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.emf.ecore.ETypedElement;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.xtext.xbase.XExpression;
import org.jspecify.annotations.Nullable;
import tools.vitruv.neojoin.Constants;
import tools.vitruv.neojoin.ast.Body;
import tools.vitruv.neojoin.ast.Export;
import tools.vitruv.neojoin.ast.Feature;
import tools.vitruv.neojoin.ast.Import;
import tools.vitruv.neojoin.ast.MainQuery;
import tools.vitruv.neojoin.ast.Query;
import tools.vitruv.neojoin.ast.SubQuery;
import tools.vitruv.neojoin.ast.ViewTypeDefinition;
import tools.vitruv.neojoin.jvmmodel.ExpressionHelper;
import tools.vitruv.neojoin.jvmmodel.TypeInfo;
import tools.vitruv.neojoin.jvmmodel.TypeResolutionException;
import tools.vitruv.neojoin.utils.AstUtils;
import tools.vitruv.neojoin.utils.Pair;
import tools.vitruv.neojoin.utils.TypeCasts;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;
import java.util.stream.Collectors;

import static tools.vitruv.neojoin.aqr.AQRInvariantViolatedException.invariant;
import static tools.vitruv.neojoin.aqr.AQRInvariantViolatedException.invariantFailed;
import static tools.vitruv.neojoin.utils.Assertions.check;
import static tools.vitruv.neojoin.utils.Assertions.fail;

/**
 * Transforms the already {@link ViewTypeDefinition abstract representation of a query} provided by Xtext into the {@link AQR}
 * by performing a series of normalizations, including:
 * <ul>
 *     <li>inferring feature types based on the Xtend expressions</li>
 *     <li>transforming subqueries into top-level queries</li>
 *     <li>generating queries for classes which are implicitly referenced (e.g. as reference type) but not explicitly generated by a separate query</li>
 *     <li>populating query target classes with features when no body was provided (e.g. {@code from Food create})</li>
 *     <li>...</li>
 * </ul>
 *
 * @implNote The implementation uses {@link AQRInvariantViolatedException#invariant(boolean) invariant(...)} for invariants
 * that should hold for {@link tools.vitruv.neojoin.validation valid} queries. Invariants that should always hold (even for
 * invalid queries) are checked with assertion methods from {@link tools.vitruv.neojoin.utils.Assertions Assertions}.
 */
public class AQRBuilder {

    private final ViewTypeDefinition viewTypeDefinition;
    private final ExpressionHelper expressionHelper;

    private final Queue<Pair<AQRTargetClass, @Nullable Body>> populationQueue = new ArrayDeque<>(); // target class + query it originated from (or null if implicit)

    private final Set<EDataType> encounteredDataTypes = new HashSet<>();

    private final Set<AQRTargetClass> targetClasses = new HashSet<>();
    private final Map<EClass, Set<AQRTargetClass>> sourceClassToAQR = new HashMap<>(); // source class -> aqr targets
    private final Map<Query, AQRTargetClass> queryToTarget = new HashMap<>(); // query (Query | SubQuery) -> target class

    public AQRBuilder(ViewTypeDefinition viewTypeDefinition, ExpressionHelper expressionHelper) {
        this.viewTypeDefinition = viewTypeDefinition;
        this.expressionHelper = expressionHelper;
    }

    /**
     * Transforms the given {@link ViewTypeDefinition} into an {@link AQR}.
     *
     * @implNote First all target classes that are explicitly generated by a query are created. Afterward these classes
     * are populated with features (see {@link #populationQueue}) and potentially missing target classes for
     * implicitly referenced source classes are created lazily when encountered.
     */
    public AQR build() {
        check(targetClasses.isEmpty(), "AQR already built");

        // create empty (= without features) target classes for all queries
        AstUtils.getAllQueries(viewTypeDefinition).forEach(this::createTargetClass);

        while (!populationQueue.isEmpty()) {
            var entry = populationQueue.poll();
            //noinspection DataFlowIssue - false positive
            populateTargetClass(entry.left(), entry.right());
        }

        var root = createRootIfNeededAndInit();

        return new AQR(
            createExport(viewTypeDefinition.getExport()),
            viewTypeDefinition.getImports().stream().map(AQRBuilder::createImport).toList(),
            encounteredDataTypes.stream().filter(dataType -> dataType.getEPackage() != EcorePackage.eINSTANCE).toList(),
            List.copyOf(targetClasses),
            root
        );
    }

    private static AQRExport createExport(Export export) {
        return new AQRExport(
            Objects.requireNonNull(export.getPackage()),
            Objects.requireNonNull(URI.createURI(export.getUri()))
        );
    }

    private static AQRImport createImport(Import imp) {
        return new AQRImport(
            Objects.requireNonNull(imp.getPackage()),
            Objects.requireNonNull(AstUtils.getImportAlias(imp))
        );
    }

    private AQRTargetClass getTargetForQuery(Query query) {
        var target = queryToTarget.get(query);
        invariant(target != null);
        return target;
    }

    private AQRTargetClass createTargetClass(String name, @Nullable AQRSource source, @Nullable Query query) {
        var target = new AQRTargetClass(name, source, new ArrayList<>());

        targetClasses.add(target);

        if (query != null) {
            var previous = queryToTarget.put(query, target);
            invariant(previous == null);
        }

        if (source != null) {
            source.allFroms().forEach(f -> {
                sourceClassToAQR.computeIfAbsent(f.clazz(), (k) -> new HashSet<>()).add(target);
            });
        }

        populationQueue.add(new Pair<>(target, query != null ? query.getBody() : null));
        return target;
    }

    private void createTargetClass(Query query) {
        switch (query) {
            case MainQuery mainQuery -> createTargetClass(
                AstUtils.getTargetName(mainQuery),
                mainQuery.getSource() != null ? AQRSourceBuilder.createSource(mainQuery.getSource()) : null,
                mainQuery
            );
            case SubQuery subQuery -> {
                var sourceType = AstUtils.inferSubQuerySourceType(subQuery, expressionHelper);
                invariant(sourceType != null);
                createTargetClass(
                    AstUtils.getTargetName(subQuery, sourceType),
                    AQRSourceBuilder.createSource(sourceType),
                    subQuery
                );
            }
            default -> fail();
        }
    }

    /**
     * Returns the existing target class associated with a source class or creates a new one if none is found.
     * Also checks that there is at most one target class associated with the given source class.
     *
     * @param source source class for which to find the corresponding target class
     * @return corresponding target class
     */
    private AQRTargetClass getOrCreateTargetClass(EClass source) {
        var targets = sourceClassToAQR.get(source);
        if (targets == null) {
            return createTargetClass(source.getName(), AQRSourceBuilder.createSource(source), null);
        }

        invariant(
            targets.size() == 1,
            () -> "Ambiguous target class for source class '%s'. Possible candidates: %s".formatted(
                source.getName(),
                targets.stream().map(AQRTargetClass::name).collect(Collectors.joining(", "))
            )
        );

        return targets.iterator().next();
    }

    /**
     * Populates the target class with features specified in the given body or copies all features if no body was given.
     *
     * @param targetClazz target class to populate
     * @param body        body of the query
     */
    private void populateTargetClass(AQRTargetClass targetClazz, @Nullable Body body) {
        if (body != null) { // create features based on definition in Body
            for (Feature feature : body.getFeatures()) {
                targetClazz.features().add(createFeature(feature));
            }
        } else { // copy all features from the source class
            invariant(targetClazz.source() != null, "Query without source must have a body");
            invariant(targetClazz.source().joins().isEmpty(), "Query with join must have a body");

            var sourceClazz = targetClazz.source().from().clazz();
            for (var feature : sourceClazz.getEStructuralFeatures()) {
                targetClazz.features().add(copyFeature(feature));
            }
        }
    }

    /**
     * Creates a feature by copying the given {@link EStructuralFeature} from the source class.
     */
    private AQRFeature copyFeature(EStructuralFeature feature) {
        var kind = new AQRFeature.Kind.Copy.Implicit(feature);
        var options = AQRFeatureOptionsBuilder.build(feature);
        return switch (feature) {
            case EAttribute attr -> {
                var type = attr.getEAttributeType();
                encounteredDataTypes.add(type);
                yield new AQRFeature.Attribute(attr.getName(), type, kind, options);
            }
            case EReference ref -> {
                var target = getOrCreateTargetClass(ref.getEReferenceType());
                yield new AQRFeature.Reference(ref.getName(), target, kind, options);
            }
            default -> fail();
        };
    }

    /**
     * Create a feature based on the given definition.
     */
    private AQRFeature createFeature(Feature feature) {
        var kind = getFeatureKind(feature);
        var name = getFeatureName(feature, kind);

        var inferredType = inferType(feature.getExpression());
        AQRFeature.Options options = AQRFeatureOptionsBuilder.build(feature, kind.source(), inferredType.isMany());

        if (isAttribute(inferredType, feature.getType())) {
            invariant(feature.getSubQuery() == null);
            var type = determineAttributeType(inferredType, (EDataType) feature.getType(), kind);
            encounteredDataTypes.add(type);
            return new AQRFeature.Attribute(name, type, kind, options);
        } else {
            var type = determineReferenceType(inferredType, (Query) feature.getType(), feature.getSubQuery());
            return new AQRFeature.Reference(name, type, kind, options);
        }
    }

    /**
     * Determines the {@link AQRFeature.Kind kind} of the feature.
     */
    private AQRFeature.Kind getFeatureKind(Feature feature) {
        return switch (feature.getOp()) {
            case COPY -> {
                try {
                    var type = expressionHelper.getFeatureOrNull(feature.getExpression());
                    invariant(
                        type != null,
                        () -> "Copy feature expression must reference a feature: " + feature.getExpression()
                    );
                    yield new AQRFeature.Kind.Copy.Explicit(type, feature.getExpression());
                } catch (TypeResolutionException e) {
                    yield invariantFailed(); // should have been handled by Xbase type checking
                }
            }
            case CALCULATE -> new AQRFeature.Kind.Calculate(feature.getExpression());
        };
    }

    /**
     * Determines the name of the feature based on the given {@link Feature} and its kind.
     */
    private static String getFeatureName(Feature feature, AQRFeature.Kind kind) {
        if (feature.getName() != null) {
            return feature.getName();
        }

        return switch (kind) {
            case AQRFeature.Kind.Copy copy -> copy.source().getName();
            case AQRFeature.Kind.Calculate ignored ->
                invariantFailed("Calculated feature must have a name: " + feature.getExpression());
            default -> fail();
        };
    }

    /**
     * Determines whether a feature is an attribute or reference based on the inferred type and the explicit type.
     *
     * @return {@code true} if the feature is an attribute, {@code false} if it is a reference
     */
    private boolean isAttribute(TypeInfo inferredType, @Nullable EObject explicitType) {
        if (explicitType != null) {
            return explicitType instanceof EDataType;
        } else {
            invariant(inferredType.classifier() != null);
            return inferredType.classifier() instanceof EDataType;
        }
    }

    /**
     * Determine the {@link EAttribute#getEAttributeType() type} of the attribute.
     */
    private EDataType determineAttributeType(
        TypeInfo inferredType,
        @Nullable EDataType explicitType,
        AQRFeature.Kind kind
    ) {
        if (explicitType != null) { // explicit type
            invariant(inferredType.classifier() == null || isAssignable(explicitType, inferredType.classifier()));
            return explicitType;
        } else { // implicit type
            invariant(inferredType.classifier() != null);
            if (kind instanceof AQRFeature.Kind.Copy copy) {
                var type = (EDataType) copy.source().getEType();
                invariant(isAssignable(type, inferredType.classifier()));
                return type;
            } else {
                return (EDataType) inferredType.classifier();
            }
        }
    }

    private static boolean isAssignable(EDataType to, EClassifier from) {
        if (to.getInstanceClass() == null || from.getInstanceClass() == null) {
            return to == from;
        } else {
            return TypeCasts.canCast(from.getInstanceClass(), to.getInstanceClass());
        }
    }

    /**
     * Determine the {@link EReference#getEReferenceType() type} of the reference.
     */
    private AQRTargetClass determineReferenceType(
        TypeInfo inferredType,
        @Nullable Query explicitType,
        @Nullable SubQuery subQuery
    ) {
        if (explicitType != null) {
            invariant(subQuery == null || explicitType == subQuery);
            if (inferredType.classifier() != null) {
                var inferredClass = (EClass) inferredType.classifier();

                // check that the inferred type is assignable to the explicit type
                if (explicitType instanceof MainQuery explicitMainQueryType) {
                    invariant(explicitMainQueryType.getSource() != null, "Cannot reference a query without source");
                    invariant(AstUtils.checkSourceType(explicitMainQueryType.getSource(), inferredClass));
                } else {
                    var explicitSubQueryType = (SubQuery) explicitType;
                    var subQuerySourceType = AstUtils.inferSubQuerySourceType(
                        explicitSubQueryType,
                        expressionHelper
                    );
                    invariant(subQuerySourceType != null);
                    invariant(AstUtils.checkSourceType(subQuerySourceType, inferredClass));
                }
            }
            return getTargetForQuery(explicitType);
        } else {
            invariant(inferredType.classifier() instanceof EClass); // includes null check
            if (subQuery != null) {
                return getTargetForQuery(subQuery);
            } else {
                return getOrCreateTargetClass((EClass) inferredType.classifier());
            }
        }
    }

    private TypeInfo inferType(XExpression expression) {
        try {
            return Objects.requireNonNull(expressionHelper.inferEType(expression));
        } catch (TypeResolutionException e) {
            return invariantFailed(); // should have been handled by Xbase type checking
        }
    }

    private AQRTargetClass createRootIfNeededAndInit() {
        AQRTargetClass root;

        var rootQuery = findRootQuery();
        if (rootQuery != null) {
            root = getTargetForQuery(rootQuery);
        } else {
            root = new AQRTargetClass(Constants.DefaultRootClassName, null, new ArrayList<>());
            targetClasses.add(root);
        }

        populateRoot(root);
        return root;
    }

    /**
     * Finds the root query of the view type definition if it exists and ensures that there is at most one.
     *
     * @return the root query if it exists, {@code null} otherwise
     */
    private @Nullable MainQuery findRootQuery() {
        var roots = viewTypeDefinition.getQueries().stream().filter(MainQuery::isRoot).toList();
        invariant(
            roots.size() <= 1,
            () -> "Multiple root queries found: " + roots.stream()
                .map(AstUtils::getTargetName)
                .collect(Collectors.joining(", "))
        );

        return roots.isEmpty() ? null : roots.getFirst();
    }

    private static final AQRFeature.Options RootReferenceOptions = new AQRFeature.Options(
        0,
        ETypedElement.UNBOUNDED_MULTIPLICITY,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        true
    );

    /**
     * Populate the root class with containment references to all other target classes.
     *
     * @param root the root target class to populate
     */
    private void populateRoot(AQRTargetClass root) {
        for (var target : targetClasses) {
            if (target == root) {
                continue;
            }

            var featureName = Constants.RootReferenceNameFormat.formatted(target.name());
            invariant(
                root.features().stream().noneMatch(f -> f.name().equals(featureName)),
                () -> "Duplicated feature name '%s' in root class".formatted(featureName)
            );
            root.features().add(
                new AQRFeature.Reference(
                    featureName,
                    target,
                    new AQRFeature.Kind.Generate(),
                    RootReferenceOptions
                )
            );
        }
    }

}
