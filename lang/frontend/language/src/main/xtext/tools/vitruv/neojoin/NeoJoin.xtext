grammar tools.vitruv.neojoin.NeoJoin
    with org.eclipse.xtext.xbase.Xbase

generate ast "http://vitruv.tools/dsls/neojoin/Ast"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

ViewTypeDefinition:
    export=Export
    imports+=Import*
    queries+=MainQuery*;

Export:
    'export' package=ID 'to' uri=STRING;

Import:
    'import' package=[ecore::EPackage|STRING] ('as' alias=ID)?;

MainQuery: ConcreteMainQuery | AbstractMainQuery;

ConcreteMainQuery:
    source=Source?
    'create' root?='root'? name=ID?
    ('extends' superClasses+=[ecore::EObject|QualifiedName] (',' superClasses+=[ecore::EObject|QualifiedName])*)?
    body=ConcreteBody?;

AbstractMainQuery:
    'abstract' name=ID
    ('extends' superClasses+=[ecore::EObject|QualifiedName] (',' superClasses+=[ecore::EObject|QualifiedName])*)?
    body=AbstractBody;

Source:
    'from' from=From
    joins+=Join*
    ('where' condition=XOrExpression)?
    ('group' 'by' groupingExpressions+=XOrExpression (',' groupingExpressions+=XOrExpression)*)?;

From:
    clazz=[ecore::EClass|QualifiedName] (alias=ID)?;

Join:
    type=JoinType? 'join' from=From (featureConditions+=JoinFeatureCondition | expressionConditions+=JoinExpressionCondition)*;

enum JoinType:
    INNER='inner' | LEFT='left';

JoinFeatureCondition:
    ('with' other=[From|ID])? 'using' features+=[ecore::EStructuralFeature|ID] (',' features+=[ecore::EStructuralFeature|ID])*;

JoinExpressionCondition:
    'on' expression=XOrExpression;

ConcreteBody:
    {ConcreteBody} '{' features+=ConcreteFeature* '}'; // {ConcreteBody} ensures that the object is created to differentiate an empty body {} from a missing body

AbstractBody:
    {AbstractBody} '{' features+=AbstractFeature* '}';

ConcreteFeature:
    (
        name=ID
        (':' type=[ecore::EObject|QualifiedName])? // type refers either to an EDataType or a Query
        (hasModifiers?='[' (modifiers+=Modifier (',' modifiers+=Modifier)*)? ']')? // allow empty modifier list in grammar and forbid it using a validator for improved error messages
        op=FeatureOp
    )?
    expression=XOrExpression
    subQuery=SubQuery?;

AbstractFeature:
    name=ID
    ':' type=[ecore::EObject|QualifiedName] // type refers either to an EDataType or a Query
    (hasModifiers?='[' (modifiers+=Modifier (',' modifiers+=Modifier)*)? ']')?; // allow empty modifier list in grammar and forbid it using a validator for improved error messages

enum FeatureOp:
    COPY='=' | CALCULATE=':=';

Modifier:
    BooleanModifier | MultiplicityExpr;

BooleanModifier:
    negated?='!'?
    name=('changeable' | 'volatile' | 'transient' | 'unsettable' | 'derived' | 'unique' | 'ordered' | 'containment' | 'id');

MultiplicityExpr:
    {MultiplicityOptional} '?' |
    {MultiplicityMany} '*' |
    {MultiplicityManyRequired} '+' |
    {MultiplicityExact} exact=INT |
    {MultiplicityBounds} lowerBound=INT '..' upperBound=INT |
    {MultiplicityManyAtLeast} lowerBound=INT '..*';

SubQuery:
    'create' (name=ID ->body=ConcreteBody? | body=ConcreteBody);

// for type hierarchy:
Query: MainQuery | SubQuery;
Body: ConcreteBody | AbstractBody;
Feature: ConcreteFeature | AbstractFeature;
